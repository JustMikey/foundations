// DO NOT EDIT THIS FILE. This file is autogenerated by Upserv Foundations.
import { Controller } from '@hotwired/stimulus'

// 1. add controller to input
// now only numbers can be entered
export default class extends Controller {
  connect() {
    // get elements
    const selectElm = this.element
    const baseId = selectElm.id
    // we loop through privous siblings rather than docuement.getElementById in
    // case there are more than 1 search select with the same ID (rails generates these
    // automatically so a new form might have the same id as an edit form if both are
    // rendered on the same page, etc.).
    let previousSibling = selectElm.previousElementSibling
    // We have to loop because rails (or other tools)
    // someimes will add elements before inputs and selectes  so we aren't sure exactly
    // where the siblings will be (otherwise, we could just get the first previousSibling
    // and the second previousSibling but this is safer)
    while (previousSibling) {
      // find the display element
      if (previousSibling.id === `${baseId}_display`) {
        this.displayElm = previousSibling
      }
      // find the search element
      if (previousSibling.id === `${baseId}_search`) {
        this.searchElm = previousSibling
      }
      // find the options element
      if (previousSibling.id === `${baseId}_options`) {
        this.optionsElm = previousSibling
      }
      // Break out of the loop if search and select elements are found
      if (this.displayElm && this.searchElm && this.optionsElm) break
      // Select the next previous sibling and restart the loop (if there is another
      // previousSibling)
      previousSibling = previousSibling.previousElementSibling
    }

    // make sure that everything comes into focus
    // when display comes into focus
    this.displayElm.addEventListener('focus', () => {
      this.displayElm.classList.add('focus')
      // no need to add focus class because search elm is literally focused
      this.searchElm.classList.add('visible')
      this.searchElm.focus()
      this.optionsElm.classList.add('visible', 'focus')
    })
    this.searchElm.addEventListener('blur', () => {
      // clear the search bar
      this.searchElm.value = null
      // update css classes
      this.displayElm.classList.remove('focus')
      this.searchElm.classList.remove('visible')
      this.optionsElm.classList.remove('visible', 'focus')
    })

    this.options = selectElm.querySelectorAll('OPTION')

    // prepare initial selection so we know whether to display the selected
    // option OR the first option when no selection has been made
    let initialSelectionMade = false
    // create pseudoOptions for display and select current option if selected
    for (var i = 0; i < this.options.length; i++) {
      // Get the current option
      let option = this.options[i]

      // Create a new div for the option
      let pseudoOption = document.createElement('div')
      if (i == 0 && !option.value)
        pseudoOption.classList.add('text-placeholder')
      pseudoOption.textContent = option.text
      pseudoOption.classList.add('pseudoOption', 'pressable')
      pseudoOption.setAttribute('data-value', option.value)
      if (option.selected == true) {
        initialSelectionMade = true
        pseudoOption.setAttribute('data-selected', 'selected')
        this.displayElm.value = option.innerHTML
      }

      // Add the new div to the optionsElm div
      this.optionsElm.appendChild(pseudoOption)
    }
    // if no initial selection, then first option is the option. Make sure
    // to display it
    if (initialSelectionMade == false) {
      this.displayElm.value = this.options[0]?.innerHTML
      this.displayElm.classList.add('text-placeholder')
    }

    // create no results pseudo option
    let noResultsPseudoOption = document.createElement('div')
    noResultsPseudoOption.textContent = 'No Results'
    noResultsPseudoOption.classList.add('noResultsPseudoOption')
    this.optionsElm.appendChild(noResultsPseudoOption)

    this.pseudoOptions = this.optionsElm.querySelectorAll('div.pseudoOption')

    // Implement "search select" - listen for the input event on the
    // input element and hide options that do not match search
    this.searchElm.addEventListener('input', () => {
      const typedText = this.searchElm.value.toLowerCase()
      // Loop through the psudo-options and hide/show them based on the typed text
      var displayedCount = 0
      for (let i = 0; i < this.options.length; i++) {
        const pseudoOption = this.pseudoOptions[i]
        const pseudoOptionText = pseudoOption.textContent.toLowerCase()
        if (pseudoOptionText.includes(typedText)) {
          pseudoOption.style.display = 'block'
          displayedCount += 1
        } else {
          pseudoOption.style.display = 'none'
        }
        if (displayedCount == 0) {
          noResultsPseudoOption.style.display = 'block'
        } else {
          noResultsPseudoOption.style.display = 'none'
        }
      }
    })

    // make selection on clicking an option
    this.optionsElm.addEventListener('mousedown', (e) => {
      e.preventDefault()
      let selectedPseudoOption = e.target.closest('div.pseudoOption')
      this.selectOption(selectedPseudoOption)
    })

    // look for specific keys like "escapte" and "enter"
    this.searchElm.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        //  blur when escape is pressed
        this.searchElm.blur()
      } else if (event.key === 'Enter' || event.key === 'Tab') {
        //  make a selection of first visible option  when "enter" or
        //  "tab" is pressed
        for (let i = 0; i < this.pseudoOptions.length; i++) {
          const pseudoOption = this.pseudoOptions[i]
          var style = window.getComputedStyle(pseudoOption)
          if (style.display !== 'none') {
            this.selectOption(pseudoOption)
            break
          }
        }
      }
    })
  }

  // since we are hacking through this and technically we make the
  // select a select multiple... when making a selection, deselect
  // everything and then select the one
  selectOption(selectedPseudoOption) {
    let selectedOption
    // only one option can be selected so start by removing selected from
    // all pseudoOptions
    for (let i = 0; i < this.pseudoOptions.length; i++) {
      this.pseudoOptions[i].classList.remove('selected')
    }

    selectedPseudoOption.classList.add('selected')
    for (let i = 0; i < this.options.length; i++) {
      const option = this.options[i]
      if (option.value == selectedPseudoOption.getAttribute('data-value')) {
        // when a select is not multiple, selecting an option deselcts previous option so no need
        // to do any de-selecting
        option.selected = true
        selectedOption = option
      }
    }

    if (selectedOption) {
      if (selectedOption.value) {
        this.displayElm.classList.remove('text-placeholder')
      } else {
        this.displayElm.classList.add('text-placeholder')
      }
      this.displayElm.value = selectedOption.innerHTML
      this.searchElm.blur()
    }
  }
}
