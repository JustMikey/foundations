// DO NOT EDIT THIS FILE. This file is autogenerated by Upserv Foundations.
import { Controller } from '@hotwired/stimulus'

// 1. add controller to input
// now only numbers can be entered
export default class extends Controller {
  connect() {
    // get elements
    const selectElm = this.element
    const baseId = selectElm.id
    // we loop through privous siblings rather than docuement.getElementById in
    // case there are more than 1 search select with the same ID (rails generates these
    // automatically so a new form might have the same id as an edit form if both are
    // rendered on the same page, etc.).
    let displayElm
    let searchElm
    let optionsElm
    let previousSibling = selectElm.previousElementSibling
    // We have to loop because rails (or other tools)
    // someimes will add elements before inputs and selectes  so we aren't sure exactly
    // where the siblings will be (otherwise, we could just get the first previousSibling
    // and the second previousSibling but this is safer)
    while (previousSibling) {
      // find the display element
      if (previousSibling.id === `${baseId}_display`) {
        displayElm = previousSibling
      }
      // find the search element
      if (previousSibling.id === `${baseId}_search`) {
        searchElm = previousSibling
      }
      // find the options element
      if (previousSibling.id === `${baseId}_options`) {
        optionsElm = previousSibling
      }
      // Break out of the loop if search and select elements are found
      if (displayElm && searchElm && optionsElm) break
      // Select the next previous sibling and restart the loop (if there is another
      // previousSibling)
      previousSibling = previousSibling.previousElementSibling
    }

    // make sure that everything comes into focus
    // when display comes into focus
    displayElm.addEventListener('focus', () => {
      displayElm.classList.add('focus')
      // no need to add focus class because search elm is literally focused
      searchElm.classList.add('visible')
      searchElm.focus()
      optionsElm.classList.add('visible', 'focus')
    })
    searchElm.addEventListener('blur', () => {
      displayElm.classList.remove('focus')
      searchElm.classList.remove('visible')
      optionsElm.classList.remove('visible', 'focus')
    })

    const options = selectElm.querySelectorAll('OPTION')

    // create pseudoOptions for display
    for (var i = 0; i < options.length; i++) {
      // Get the current option
      var option = options[i]

      // Create a new div for the option
      var pseudoOption = document.createElement('div')
      pseudoOption.textContent = option.text
      pseudoOption.classList.add('pseudoOption', 'pressable')
      pseudoOption.setAttribute('data-value', option.value)
      if (option.selected == true) {
        pseudoOption.setAttribute('data-selected', 'selected')
      }

      // Add the new div to the optionsElm div
      optionsElm.appendChild(pseudoOption)
    }
    const pseudoOptions = optionsElm.querySelectorAll('div.pseudoOption')
    // these are needed elsewhere so makeing them class vars (is that what you call in js?)
    this.displayElm = displayElm
    this.searchElm = searchElm
    this.options = options
    this.pseudoOptions = pseudoOptions

    // Implement "search select" - listen for the input event on the
    // input element and hide options that do not match search
    searchElm.addEventListener('input', function () {
      const typedText = searchElm.value.toLowerCase()
      // Loop through the psudo-options and hide/show them based on the typed text
      for (let i = 0; i < options.length; i++) {
        const pseudoOption = pseudoOptions[i]
        const pseudoOptionText = pseudoOption.textContent.toLowerCase()
        if (pseudoOptionText.includes(typedText)) {
          pseudoOption.style.display = 'block'
        } else {
          pseudoOption.style.display = 'none'
        }
      }
    })

    // make selection on clicking an option
    optionsElm.addEventListener('mousedown', (e) => {
      e.preventDefault()
      let selectedPseudoOption = e.target.closest('div.pseudoOption')
      this.selectOption(selectedPseudoOption)
    })

    // look for specific keys like "escapte" and "enter"
    searchElm.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        //  blur when escape is pressed
        searchElm.blur()
      } else if (event.key === 'Enter') {
        //  make a selection of first visible option  when "enter" is pressed
        for (let i = 0; i < pseudoOptions.length; i++) {
          const pseudoOption = pseudoOptions[i]
          var style = window.getComputedStyle(pseudoOption)
          if (style.display !== 'none') {
            this.selectOption(pseudoOption)
            break
          }
        }
      }
    })
  }

  // since we are hacking through this and technically we make the
  // select a select multiple... when making a selection, deselect
  // everything and then select the one
  selectOption(selectedPseudoOption) {
    let selectedOption
    for (let i = 0; i < this.pseudoOptions.length; i++) {
      this.pseudoOptions[i].classList.remove('selected')
    }

    selectedPseudoOption.classList.add('selected')
    for (let i = 0; i < this.options.length; i++) {
      const option = this.options[i]
      if (option.value == selectedPseudoOption.getAttribute('data-value')) {
        // when a select is not multiple, selecting an option deselcts previous option so no need
        // to do any de-selecting
        option.selected = true
        selectedOption = option
      }
    }

    if (selectedOption) {
      this.displayElm.value = selectedOption.innerHTML
      this.searchElm.blur()
    }
  }
}
