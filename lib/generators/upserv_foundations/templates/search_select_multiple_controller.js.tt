// DO NOT EDIT THIS FILE. This file is autogenerated by Upserv Foundations.
import { Controller } from '@hotwired/stimulus'

// 1. add controller to input
// now only numbers can be entered
export default class extends Controller {
  connect() {
    // get elements
    const selectedOptionsContainer = this.element
    // selectedOptionsContainer id should end in -selected-options
    // so the base id is everythng but "-selected-options"
    // so remvoe the last 17 characters
    const baseId = selectedOptionsContainer.id.slice(0, -17)
    // we loop through privous siblings rather than docuement.getElementById in
    // case there are more than 1 search select with the same ID (rails generates these
    // automatically so a new form might have the same id as an edit form if both are
    // rendered on the same page, etc.).
    let searchElm
    let selectElm
    let previousSibling = selectedOptionsContainer.previousElementSibling
    // We have to loop because rails (or other tools)
    // someimes will add elements before inputs and selectes  so we aren't sure exactly
    // where the siblings will be (otherwise, we could just get the first previousSibling
    // and the second previousSibling but this is safer)
    while (previousSibling) {
      // find the search element
      if (previousSibling.id === `${baseId}_search`) {
        searchElm = previousSibling
      }
      // find the select element
      if (previousSibling.id === baseId) {
        selectElm = previousSibling
      }
      // Break out of the loop if search and select elements are found
      if (searchElm && selectElm) break
      // Select the next previous sibling and restart the loop (if there is another
      // previousSibling)
      previousSibling = previousSibling.previousElementSibling
    }

    // make sure that both input and select come into focus
    // when either one comes into focus (and vice vers for leaving
    // focus)
    selectElm.addEventListener('focus', () => {
      searchElm.classList.add('focus')
    })
    selectElm.addEventListener('blur', () => {
      searchElm.classList.remove('focus')
    })
    searchElm.addEventListener('focus', () => {
      selectElm.classList.add('focus')
    })
    searchElm.addEventListener('blur', () => {
      selectElm.classList.remove('focus')
    })

    // selectElm and options are needed for other methods in this class
    this.selectElm = selectElm
    const options = selectElm.querySelectorAll('option')
    this.options = options

    // prep currently selected elements by hiding them on the select
    // and adding them to the selectedOptionsContainer
    for (let i = 0; i < options.length; i++) {
      const option = options[i]
      if (option.hasAttribute('selected')) {
        option.style.display = 'none'
        const newElm = this.createSelectedOptionElm(option)
        selectedOptionsContainer.appendChild(newElm)
      }
    }

    // Implement "search select" - listen for the input event on the
    // input element and hide options that do not match search
    searchElm.addEventListener('input', function () {
      const typedText = searchElm.value.toLowerCase()
      // Loop through the options and hide/show them based on the typed text
      for (let i = 0; i < options.length; i++) {
        const option = options[i]
        const optionText = option.textContent.toLowerCase()
        if (
          !option.hasAttribute('selected') &&
          optionText.includes(typedText)
        ) {
          option.style.display = 'block'
        } else {
          option.style.display = 'none'
        }
      }
    })

    // add items to selected list when clicked
    const createSelectedOptionElm = this.createSelectedOptionElm
    selectElm.addEventListener('mousedown', function (e) {
      e.preventDefault()
      let option = e.target.closest('option')
      if (option) {
        option.style.display = 'none'
        option.setAttribute('selected', 'selected')
        const newElm = createSelectedOptionElm(option)
        selectedOptionsContainer.appendChild(newElm)
      }
    })
  }

  // helper method for creating elements for the options that have been selected
  createSelectedOptionElm(option) {
    const selectedOption = document.createElement('div')
    selectedOption.classList.add(
      'search-select-multiple-selected-option-display'
    )
    const displayElm = document.createElement('div')
    displayElm.textContent = option.textContent
    selectedOption.appendChild(displayElm)
    const close = document.createElement('span')
    close.classList.add('search-select-multiple-selected-option-close')
    close.textContent = '\u00D7'
    close.setAttribute('data-value', option.value)
    close.setAttribute('data-action', 'click->search-select-multiple#deSelect')
    selectedOption.appendChild(close)
    return selectedOption
  }

  // deselect options - remove the selected option element and unhide the option
  // in the select element
  deSelect(event) {
    const value = event.target.dataset.value
    // find the option in the select element
    let optionToDeselect = null
    for (let i = 0; i < this.options.length; i++) {
      if (this.options[i].getAttribute('value') === value) {
        optionToDeselect = this.options[i]
        break
      }
    }
    // unslect the option and display it
    optionToDeselect.removeAttribute('selected')
    optionToDeselect.style.display = 'block'
    // remove the selected option display element (ie the element that was
    // just clicked) - note: the element wasn't clicked but rather it's child
    // was clicked (the span with an X). So don't remove the element that was clicked
    // but rather remove it's parent
    event.target.parentNode.remove()
  }
}
